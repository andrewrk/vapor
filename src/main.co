#depend "chem"

const from_base64 = atob or alert "this browser can't decode base64 data"

const b2Vec2 = Box2D.Common.Math.b2Vec2
const b2BodyDef = Box2D.Dynamics.b2BodyDef
const b2Body = Box2D.Dynamics.b2Body
const b2FixtureDef = Box2D.Dynamics.b2FixtureDef
const b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef
const b2World = Box2D.Dynamics.b2World
const b2DebugDraw = Box2D.Dynamics.b2DebugDraw
const b2AABB = Box2D.Collision.b2AABB
const b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
const b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape
const b2CircleShape = Box2D.Collision.Shapes.b2CircleShape

# ugh. make this api more coffee-like
query_aabb = (world, aabb, callback) ->
  # callback should be the last parameter
  actual_callback = (fixture) ->
    # invert the return value, so that the default case continues
    !callback fixture
  world.QueryAABB callback, aabb

map = null
let
  waiting_events = []
  create_wait_condition = (name) ->
    index = waiting_events.length
    waiting_events.push name
    !->
      waiting_events[index] = null
      done = true
      list = document.getElementById "loading-list"
      list.innerHTML = ""
      for event_name of waiting_events
        continue unless event_name?
        item = document.createElement "li"
        item.innerHTML = event_name
        list.appendChild item
        done = false
      if done
        document.getElementById("loading").setAttribute "style", "display:none;"
        init!

  Chem.onReady create_wait_condition "sprites"

  map_is_ready = create_wait_condition "map"
  request = new XMLHttpRequest!
  request.onreadystatechange = !->
    return unless request.readyState is 4 and request.status is 200
    map := parse_map request.responseText
    map_is_ready!
  request.open "GET", "map.tmx", true
  request.send!

  parse_map = ->
    xml = new DOMParser!.parseFromString it, "text/xml"
    root = xml.getElementsByTagName("map")[0]
    tilesets = []
    for tileset of root.getElementsByTagName "tileset"
      first_gid = parseInt tileset.getAttribute "firstgid"
      image_tag = tileset.getElementsByTagName("image")[0]
      image = new Image!
      image.src = image_tag.getAttribute "source"
      image.onload = create_wait_condition "tileset"
      tilesets.push([first_gid, image])
    layers = []
    for layer_tag of root.getElementsByTagName "layer"
      width  = parseInt layer_tag.getAttribute "width"
      height = parseInt layer_tag.getAttribute "height"
      data_tag = layer_tag.getElementsByTagName("data")[0]
      if data_tag.getAttribute("compression")
        alert "can't decompress map. store maps with base64 uncompressed data."
        return
      data_string = from_base64 data_tag.textContent.trim!
      i = 0
      layers.push layer = []
      for y from 0 til height
        layer.push row = []
        for x from 0 til width
          tile_value  = data_string.charCodeAt(i++)
          tile_value |= data_string.charCodeAt(i++) << 8
          tile_value |= data_string.charCodeAt(i++) << 16
          tile_value |= data_string.charCodeAt(i++) << 24
          row.push tile_value
    return {tilesets, layers}

init = ->
  const canvas = document.getElementById "game"
  const canvas_center = new Chem.Vec2d canvas.getAttribute("width")/2, canvas.getAttribute("height")/2
  const engine = new Chem.Engine canvas
  const man_sprite = new Chem.Sprite 'man',
    z_order: 1

  # GIMME THE FIZZAQS!
  const view_scale = 32
  world = null
  debugDrawer = null
  debugDrawing = true
  man_body = null
  feet_body = null
  let
    gravity = new b2Vec2 0, 30
    world := new b2World gravity, true

    debugDrawer := new b2DebugDraw()
    debugDrawer.SetSprite canvas.getContext "2d"
    debugDrawer.SetDrawScale view_scale
    debugDrawer.SetFillAlpha 0.5
    debugDrawer.SetLineThickness 1
    debugDrawer.SetFlags b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit
    world.SetDebugDraw debugDrawer

    fixture_def = new b2FixtureDef!
    fixture_def.density = 1.0
    fixture_def.friction = 0.5
    fixture_def.restitution = 0

    # create the room
    let
      # we create the physics of the walls as the outlines.
      # this prevents you from bumping along the corners in the ground.
      # see e5022e9137d1b81442d7049e0ff7d4d2d25ab679
      endpoint_to_line = {}
      tile_value_at = (x, y) -> (map.layers[y] ? [])[x] ? 0
      add_segment = (x1, y1, x2, y2) ->
        atan2 = Math.atan2 y2 - y1, x2 - x1
        old_key = [x1,y1].toString!
        new_key = [x2,y2].toString!
        existing_lines = endpoint_to_line[old_key] ? []
        for existing_line of existing_lines
          if existing_line.atan2 is not atan2
            continue
          # extend existing line
          delete endpoint_to_line[old_key]
          existing_line.x2 = x2
          existing_line.y2 = y2
          endpoint_to_line[new_key] = existing_line
          return
        endpoint_to_line[new_key] = {x1,y1,x2,y2}
      # create walls from the map
      for layer of map.layers
        # overshoot by 1
        for y from 0 to layer.length
          for x from 0 to layer[0].length
            if (tile_value_at(x, y) is not 0) is not (tile_value_at(x, y-1) is not 0)
              add_segment x, y, x+1, y
            if (tile_value_at(x, y) is not 0) is not (tile_value_at(x-1, y) is not 0)
              add_segment x, y, x, y+1

      for _, line in endpoint_to_line
        body_def = new b2BodyDef!
        body_def.type = b2Body.b2_staticBody
        body_def.position.x = (line.x1 + line.x2) / 2
        body_def.position.y = (line.y1 + line.y2) / 2
        # can't use b2EdgeShape, because it's not implemented. See https://code.google.com/p/box2dweb/issues/detail?id=31
        fixture_def.shape = new b2EdgeShape(
          new b2Vec2 line.x1, line.y1
          new b2Vec2 line.x2, line.y2
        )
        world.CreateBody(body_def).CreateFixture fixture_def

    # create the man
    body_def = new b2BodyDef!
    body_def.type = b2Body.b2_dynamicBody
    fixture_def.friction = 0
    fixture_def.shape = new b2PolygonShape!
    fixture_def.shape.SetAsBox 0.4, 1.1
    body_def.position.x = 40
    body_def.position.y = 43
    body_def.fixedRotation = true
    man_body := world.CreateBody body_def
    body_def.fixedRotation = false
    man_body.SetUserData man_sprite
    man_body.CreateFixture fixture_def

    body_def.position.y += 1.1
    feet_body := world.CreateBody body_def
    fixture_def.shape = new b2CircleShape 0.4 - 0.01
    fixture_def.restitution = 0
    fixture_def.friction = 3
    feet_body.CreateFixture fixture_def
    # feet_body.SetUserData new Chem.Sprite 'ship'

    joint_def = new b2RevoluteJointDef!
    joint_def.Initialize man_body, feet_body, feet_body.GetWorldCenter!
    world.CreateJoint joint_def

  is_grounded = null
  engine.on 'update', (dt, dx) ->

    debugDrawing := !debugDrawing if engine.buttonJustPressed Chem.Button.Key_Grave

    is_grounded := do ->
      contact_edge = feet_body.GetContactList!
      while contact_edge
        if contact_edge.contact.IsTouching!
          return true
        contact_edge = contact_edge.next
      false

    man_velocity = man_body.GetLinearVelocity!

    # left/right
    horizontal_intention = 0
    horizontal_intention-- if engine.buttonState Chem.Button.Key_Left
    horizontal_intention++ if engine.buttonState Chem.Button.Key_Right
    # rotate feet wheel to move on the ground
    feet_angular_velocity = 30 * horizontal_intention
    feet_body.SetAngularVelocity feet_angular_velocity
    feet_body.SetFixedRotation horizontal_intention is 0
    feet_body.SetAwake true
    # additional left/right control for in the air
    feet_radius = feet_body.GetFixtureList!.m_shape.m_radius
    feet_max_velocity = feet_angular_velocity * feet_radius
    magic_max_velocity = 0.8 * feet_max_velocity
    if horizontal_intention * man_velocity.x < horizontal_intention * magic_max_velocity
      # magic acceleration
      man_body.ApplyImpulse new b2Vec2(0.25 * horizontal_intention, 0), man_body.m_xf.position

    # JOMP!
    jump_button = Chem.Button.Key_Space
    if is_grounded and engine.buttonJustPressed jump_button
      man_body.ApplyImpulse new b2Vec2(0, -41), man_body.m_xf.position
    const jump_stop = -5
    if not engine.buttonState jump_button and man_velocity.y < jump_stop
      man_velocity.y = jump_stop

    world.Step dt, 10, 10
    world.ClearForces!

  world_to_canvas = ->
    in_pixels = new Chem.Vec2d(it).sub(man_body.m_xf.position).scale(view_scale)
    # snap to integer pixels to prevent seeing cracks between tiles
    in_pixels.floor!
    return in_pixels.add(canvas_center)
  get_view_aabb = ->
    result = new b2AABB
    result.lowerBound.x = man_body.m_xf.position.x - canvas_center.x / view_scale
    result.lowerBound.y = man_body.m_xf.position.y - canvas_center.y / view_scale
    result.upperBound.x = man_body.m_xf.position.x + canvas_center.x / view_scale
    result.upperBound.y = man_body.m_xf.position.y + canvas_center.y / view_scale
    result

  engine.on 'draw', (context) ->
    # clear canvas to black
    context.fillStyle = '#000000'
    context.fillRect 0, 0, engine.size.x, engine.size.y

    if debugDrawing
      context.save!
      center = world_to_canvas new Chem.Vec2d 0, 0
      context.translate center.x, center.y
      world.DrawDebugData!
      context.restore!

    else
      # figure out which bodies to draw
      sprite_batch = new Chem.Batch!
      query_aabb world, get_view_aabb!, (fixture) ->
        body = fixture.GetBody!
        sprite = body.GetUserData!
        if sprite instanceof Chem.Sprite
          # set the positions of sprite
          sprite.pos = world_to_canvas body.m_xf.position
          sprite.rotation = body.m_xf.GetAngle!
          sprite_batch.add sprite
        else if (fixture = body.GetFixtureList!)?
          # just draw the bounding box
          context.fillStyle = '#ffff66'
          lower_bound = world_to_canvas fixture.GetAABB!.lowerBound
          upper_bound = world_to_canvas fixture.GetAABB!.upperBound
          context.fillRect(
            lower_bound.x
            lower_bound.y
            upper_bound.x - lower_bound.x
            upper_bound.y - lower_bound.y
          )
        body = body.m_next

      # draw the sprites in front of the above walls
      engine.draw sprite_batch

    # draw a little fps counter in the corner
    context.fillStyle = '#ffffff'
    engine.drawFps!
    context.fillText "grounded = #{is_grounded}", 100, canvas_center.y * 2

  engine.start!
  canvas.focus!

